eval := procedure(expr) {
	if (isString(expr)) {
		expr := parse(expr);
	}
	if (true) {
		print("Evaluating $expr$...");
	}
	match(expr) {
		case @Number(n):
			return expr;
		case @Name(s):
			return expr;
		case @Func(f, params):
			assert(false, "evaluating functions is not yet implemented");
		case @Op(op, params, _):
			assert(false, "evaluating operators is not yet implemented");
		default: abort("Error at eval($expr$) - Unknown Expression.");
	}
};

getMaxPrec := procedure() {
	return 3;
};

getOpPrec := procedure(op) {
	match(op) {
		case "**":
			return 3;
		case "*":
			return 2;
		case "/":
			return 2;
		case "+":
			return 1;
		case "-":
			return 1;
		default:
			abort("Error at getOpPrec($op$) - Unknown operator");
	}
};

isOpRightAssoc := procedure(op) {
	match(op) {
		case "**":
			return true;
		default:
			return false;
	}
};

idxOfClosedParan := procedure(tokens) {
	parans := 1;
	i := 1;
	while (parans != 0 && #tokens >= i) {
		match(tokens[i]) {
			case @TokParanOpen():
				parans += 1;
			case @TokParanClosed():
				parans -= 1;
		}
		i += 1;
	}

	if (parans == 0) {
		return i;
	} else {
		abort("Error at idxOfClosedParan($tokens$): Unmatched Parantheses.");
	}
};

parse := procedure(tokens) {
	if (isString(tokens)) {
		tokens := tokenize(tokens);
	}
	return parseExpr(tokens);
};

parseExprList := procedure(tokens) {
	if (true) {
		print("Parsing expression-list $tokens$...");
	}
	assert(false, "parseExprList is not yet implemented");
	res := [];
	// while(test) {
	// 	body
	// }
	return res;
};

parseExpr := procedure(tokens, last := om, paranLevel := 0) {
	if (true) {
		print("Parsing expression $tokens$ with last: $last$...");
	}
	if (tokens == []) {
		return last;
	}
	if (last == om) {
		return parseTerm(tokens, true, paranLevel);
	}

	expr := om;
	match(tokens[1]) {
		case @TokOp(op):
			next := parseTerm(tokens[2..], false, paranLevel);
			currPrec := getOpPrec(op) + paranLevel * getMaxPrec();
			if (true) {
				print("next: $next$");
				print("currPrec: $currPrec$");
			}
			if (fct(last) == "Op") {
				[lastOp, params, lastPrec] := args(last);
				assert(#params >= 2, "There must be at least 2 parameters for a prefix operator. The operator $lastOp$ only received the parameters $params$");

				if (op == lastOp) {
					if (isOpRightAssoc(op)) {
						expr := @Op(op, [next] + params, currPrec);
					} else {
						expr := @op(op, params + [next], currPrec);
					}
				} else {
					if (currPrec > lastPrec) {
						expr := @Op(lastOp, params[..-2] + [@Op(op, [params[-1], next])], currPrec);
					} else {
						expr := @Op(op, [last, next], currPrec);
					}
				}
			} else {
				expr := @Op(op, [last, next], currPrec);
			}
		default:
			expr := parseTerm(tokens, false, paranLevel);
	}
	if (true) {
		print("Parsing done - Result: $expr$");
	}
	return expr;
};

parseTerm := procedure(rw tokens, rec := false, paranLevel := 0) {
	assert(tokens != [], "parseTerm expects a non-empty list as input");
	if (true) {
		print("Parsing term $tokens$ with rec: $rec$...");
	}
	match(tokens[1]) {
		case @TokNum(num):
			tokens := tokens[2..];
			if (rec) {
				return parseExpr(tokens, @Number(num), paranLevel);
			} else {
				return @Number(num);
			}
		case @TokName(name):
			// Name + ParanOpen + ParanClosed are required for it to be a function-call
			if (#tokens > 3 && fct(tokens[2]) == "TokParanOpen") {
				idx := idxOfClosedParan(tokens[3..]);
				params := parseExprList(tokens[3..idx], om, paranLevel);
				tokens := tokens[idx+2..];
				if (rec) {
					return parseExpr(tokens, @Func(name, params), paranLevel);
				} else {
					return @Func(name, params);
				}
			} else {
				tokens := tokens[2..];
				if (rec) {
					return parseExpr(tokens, @Name(name), paranLevel);
				} else {
					return @Name(name);
				}
			}
		case @TokParanOpen():
			idx := idxOfClosedParan(tokens[2..]);
			expr := parseExpr(tokens[2..idx-1], om, paranLevel + 1);
			tokens := tokens[idx+1..];
			if (rec) {
				return parseExpr(tokens, expr, paranLevel);
			} else {
				return expr;
			}
		default: abort("Error at parseTerm($tokens$) - Unexpected token");
	}
};

tokenize := procedure(str) {
	if (true) {
		print("Tokenizing $str$...");
	}
	toks := [];
	scan(str) {
		regex '\s+': // Skip starting whitespace
		regex '[a-zA-Z][a-zA-Z_0-9]*' as [ name ]:
			toks += [ @TokName(name) ];
		regex '0|[1-9][0-9]*' as [ num ]:
			toks += [ @TokNum(num) ];
		regex '\(':
			toks += [ @TokParanOpen() ];
		regex '\)':
			toks += [ @TokParanClosed() ];
		regex ',':
			toks += [ @TokComma() ];
		regex '\*\*|[+\-\*/]' as [ op ]:
			toks += [ @TokOp(op) ];
		default: abort("Error at tokenize($str$) - Can't tokenize $str$ properly");
	}
	return toks;
};

stringify := procedure(expr, outsideOp := om) {
	if (true) {
		print("Stringifying $expr$ with outsideOp = $outsideOp$...");
	}
	assert(false, "stringify is not yet implemented");
};

evalStr := procedure(str) {
	tokens := tokenize(str);
	expr := parse(tokens);
	res := eval(expr);
	return stringify(res);
};



print(evalStr("(a + 7) * 34"));
print(evalStr("diff(diff(x * x * y, x), y)"));
print(evalStr("diff(sin(cos(x)), x)"));