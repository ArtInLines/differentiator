class global() {
	static {
		DEBUG := false;
	}
}

reduceFromFirst := procedure(l, f, rev := false) {
	assert(l != [], "reduceFromFirst expects a non-empty list as input");
	if (rev) {
		res := l[-1];
		for (i in {2..#l}) {
			res := f(l[-i], res);
		}
		return res;
	} else {
		res := l[1];
		for (x in l[2..]) {
			res := f(res, x);
		}
		return res;
	}
};

join := procedure(l, del := ", ") {
	match(l) {
		case []:    return "";
		case [x]:   return "$x$";
		case [x|r]: return "$x$$del$$join(r, del)$";
	}
};

// Returns true, if at least f(x) returns true for at least two elements in l
some := procedure(l, f) {
	foundOne := false;
	for (x in l) {
		if (f(x)) {
			if (!foundOne) {
				foundOne := true;
			} else {
				return true;
			}
		}
	}
	return false;
};

// Splits a list in two sublists.
// The first sublists contains all elements for which f(x) is true.
// The second sublist contains all other elements.
splitListInTwo := procedure(l, f) {
	a := [];
	b := [];
	for (x in l) {
		if (f(x)) {
			a += [x];
		} else {
			b += [x];
		}
	}
	return [a, b];
};

addOpRule := procedure(rw rules, op, test, eval) {
	if (op in domain(rules)) {
		rules[op] += [[test, eval]];
	} else {
		rules[op] := [[test, eval]];
	}
	return rules;
};

addOpRules := procedure(rw rules, op, newRules) {
	for (newRule in newRules) {
		assert(#newRule == 2, "An evalutation rule always has to consist of exactly two functions, a test and an eval function.");
		addOpRule(rules, op, newRule[1], newRule[2]);
	}
	return rules;
};

allNumRule := procedure(reduceOp, reversed := false) {
	return [
		params |-> forall (p in params | fct(p) == "Number"),
		params |=> @Number(reduceFromFirst([ args(p)[1] : p in params ], reduceOp, reversed))
	];
};

someNumRule := procedure(op, reduceOp, reversed := false) {
	return [
		params |-> some(params, p |-> fct(p) == "Number"),
		closure(params) {
			[ nums, others ] := splitListInTwo(params, p |-> fct(p) == "Number");
			n := reduceFromFirst([ args(n)[1] : n in nums ], reduceOp, reversed);
			if (others == []) {
				return @Number(n);
			} else {
				return @Op(op, others + [@Number(n)]);
			}
		}
	];
};

someNumAfterFirstRule := procedure(op, reduceOp) {
	return [
		params |-> some(params[2..], p |-> fct(p) == "Number"),
		closure(params) {
			[ nums, others ] := splitListInTwo(params[2..], p |-> fct(p) == "Number");
			n := reduceFromFirst([ args(n)[1] : n in nums ], reduceOp);
			return @Op(op, [params[1]] + others + [@Number(n)]);
		}
	];
};

class cachedExprRuleClass(op, calcCacheVal, replace) {
	op := op;
	calcCacheVal := calcCacheVal;
	replace := replace;
	cachedVal := om;
	test := procedure(params) {
		cachedExprs := {};
		for (p in params) {
			val := this.calcCacheVal(p);
			if (val != om) {
				if (val in cachedExprs) {
					this.cachedVal := val;
					return true;
				}
				cachedExprs += {val};
			}
		}
		return false;
	};
	eval := procedure(params) {
		assert(this.cachedVal != om, "Cached Value shouldn't be able to be om, since values that are om should get discarded.");
		[ sames, others ] := splitListInTwo(params, p |=> cachedVal == calcCacheVal(p));
		replacement := this.replace(sames);
		if (others == []) {
			return replacement;
		} else {
			return @Op(this.op, others + [replacement]);
		}
	};
}

// op is the operation combining the other values with the replacement of the matched value (usually the same operation as the one for which the rule is defined)
// calcCacheVal is a function taking a single expression as input. It should return a cache value for comparing with the cache values of the other parameters in params. Return `om` if you want to ignore said expression. If there are two or more expression with the same cache value, the rule applies.
// replace is a function taking the list of expressions, that were matched as same with calcCacheVal. It should return an expression to use in their stead. If all expressions matched it, the replacement will be returned directly. Otherwise it will be connected with the other expression using the operator from `op`.
cachedExprRule := closure(op, calcCacheVal, replace) {
	r := cachedExprRuleClass(op, calcCacheVal, replace);
	return [params |=> r.test(params), params |=> r.eval(params)];
};

someSameExprsRule := procedure(op, replace) {
	return cachedExprRule(op, p |-> p, replace);
};

neutralElRule := procedure(op, e) {
	return [
		params |=> exists (p in params | fct(p) == "Number" && args(p)[1] == e),
		closure(params) {
			params := [ p : p in params | fct(p) != "Number" || args(p)[1] != e ];
			if (#params == 1) {
				return params[1];
			} else {
				return @Op(op, params);
			}
		}
	];
};

neutralElAfterFirstRule := procedure(op, e) {
	return [
		params |=> exists (p in params[2..] | fct(p) == "Number" && args(p)[1] == e),
		closure(params) {
			remaining := [ p : p in params[2..] | fct(p) != "Number" || args(p)[1] != e ];
			if (#remaining == 0) {
				return params[1];
			} else {
				return @Op(op, [params[1]] + remaining);
			}
		}
	];
};

nullElRule := procedure(op, null, res) {
	return [
		params |=> exists (p in params | fct(p) == "Number" && args(p)[1] == null),
		params |=> res
	];
};

// cmpType can be positive, negative or 0. If 0, the arity has to be equal to the provided one. If positive, the arity has to be greater than or equal. If negative, the arity has to be less than or equal.
checkArityRule := procedure(op, arity, cmpType := 0) {
	return [
		closure(params) {
			if (cmpType == 0) {
				return #params != arity;
			} else if (cmpType < 0) {
				return #params > arity;
			} else {
				return #params < arity;
			}
		},
		params |=> abort("$op$ exprects $arity$ argument(s), but received $#params$ argument(s).")
	];
};

chainRule := procedure(f, innerRules) {
	// Assume each rule in innerRules is a list with two elements, where the first element is the name of the function and the second element is a function taking the parameters as input and returning an expression as output
	return [
		params |=> fct(params[1]) == "Func" && args(params[1])[1] in domain(innerRules),
		closure(params) {
			fname := args(params[1])[1];
			fparams := args(params[1])[2];
			otherParams := params[2..];
			fdiff := innerRules[fname];
			return @Op("*", [@Func(f, fparams + otherParams), fdiff(fparams)]);
		}
	];
};

makeRules := procedure(rules, singleRulePerOp := false) {
	res := {};
	for (r in rules) {
		assert(#r == 2, "Every rule must be a list with two elements.");
		if (singleRulePerOp) {
			res[r[1]] := r[2];
		} else {
			addOpRules(res, r[1], r[2]);
		}
	}
	return res;
};

makeDiffFuncRules := procedure() {
	return makeRules([
		["sin", params |-> @Func("cos", params)],
		["cos", params |-> @UnaryOp("-", @Func("sin", params))]
	], true);
};

makeDefaultRules := procedure(diffFuncRules := makeDiffFuncRules()) {
	return makeRules([
		["**", [
			checkArityRule("**", 2, 1),
			nullElRule("**", 0, @Number(1)),
			someNumRule("**", [a, b] |-> a ** b, true),
			neutralElRule("**", 1),
			[
				params |-> #params > 2,
				params |-> @Op("**", [params[1], @Op("*", params[2..])])
			]
		]],
		["+", [
			checkArityRule("+", 2, 1),
			someNumRule("+", [a, b] |-> a + b),
			someSameExprsRule("+", sames |-> @Op("*", [@Number(#sames), sames[1]])),
			neutralElRule("+", 0)
		]],
		["*", [
			// Must have at least 2 operands
			checkArityRule("*", 2, 1),
			// 0 * a == 0
			nullElRule("*", 0, @Number(0)),
			// calculate number operands
			someNumRule("*", [a, b] |-> a * b),
			// a * a == a ** 2
			someSameExprsRule("*", sames |-> @Op("**", [sames[1], @Number(#sames)])),
			// a * 1 == a
			neutralElRule("*", 1),
			// (a ** b) * (a ** c) == a ** (b + c)
			cachedExprRule("*", procedure(p) {
				match(p) {
					case @Op(op, params):
						if (op == "**") {
							return params[1];
						} else {
							return om;
						}
					case @Func(f, params):
						return om;
					case @Name(x):
						return x;
					case @Number(x):
						return x;
				}
			}, procedure(sames) {
				// whether "**" operation, name or number, the base is always given by the first argument
				base := args(sames[1])[1];
				exps := [];
				for (x in sames) {
					if (fct(x) == "Op") {
						l := args(x)[2..];
						if (#l == 1) {
							exps += l;
						} else {
							exps += [@Op("*", l)];
						}
					} else {
						exps += [@Number(1)];
					}
				}
				return @Op("**", [base, @Op("+", exps)]);
			}),
			// a * b * (c +/- d)  ==  a * b * c  +/-  a * b * d
			// TODO: Currently only applies if there is exactly one paranthesized expression - is this wanted?
			// TODO: Port rule to "/" (or generalize into an abstract rule?)
			[
				params |-> #[p : p in params | fct(p) == "Op" && args(p)[1] in {"+", "-"}] == 1 && exists ( p in params | fct(p) != "Op" || args(p)[1] notin {"+", "-"} ),
				procedure(params) {
					[distributables, others] := splitListInTwo(params, p |-> fct(p) == "Op" && args(p)[1] in {"+", "-"});

					assert(#distributables == 1, "Rule should currently only apply if there is exactly one paranthesized expression to distribute");
					[distOp, distParams] := args(distributables[1]);
					return @Op(distOp, [ @Op("*", others + [dp]) : dp in distParams ]);
				}
			]
		]],
		["-", [
			[
				params |-> #params == 1,
				params |-> @Op("-", [@Number(0)] + params)
			],
			checkArityRule("-", 2, 1),
			allNumRule([a, b] |-> a - b),
			someNumAfterFirstRule("-", [a, b] |-> a + b),
			neutralElAfterFirstRule("-", 0)
		]],
		["/", [
			checkArityRule("/", 2, 1),
			[
				params |-> exists (p in params[2..] | fct(p) == "Number" && args(p)[1] == 0),
				params |-> abort("Division by 0,")
			],
			[
				params |-> fct(params[1]) == "Number" && args(params[1])[1] == 0,
				params |-> @Number(0)
			],
			allNumRule([a, b] |-> a / b),
			someNumAfterFirstRule("/", [a, b] |-> a * b),
			neutralElAfterFirstRule("/", 1)
		]],
		["diff", [
			checkArityRule("diff", 2),
			[
				params |-> fct(params[1]) == "Number",
				params |-> @Number(0)
			],
			[
				params |-> fct(params[1]) == "Name" && params[1] == params[2],
				params |-> @Number(1)
			],
			[
				params |-> fct(params[1]) == "Name",
				params |-> @Number(0)
			],
			[
				params |-> fct(params[1]) == "Op" && args(params[1])[1] == "+",
				params |-> @Op("+", [ @Func("diff", [x, params[2]]) : x in args(params[1])[2] ])
			],
			[
				params |-> fct(params[1]) == "Op" && args(params[1])[1] == "-",
				params |-> @Op("-", [ @Func("diff", [x, params[2]]) : x in args(params[1])[2] ])
			],
			[
				params |-> fct(params[1]) == "Op" && args(params[1])[1] == "**",
				procedure(params) {
					sym := params[2];
					opTerm := params[1];
					base := args(opTerm)[2][1];
					exps := args(opTerm)[2][2..];
					if (base == sym) {
						// TODO:
						assert(#exps == 1 && fct(exps[1]) == "Number", "Differentiation of exponents that are more complex expressions than single numbers aren't implemented yet.");
						n := args(exps[1])[1];
						if (n == 0) {
							return @Func("diff", @Number(1));
						} else if (n == 1) {
							return @Func("diff", sym);
						} else {
							return @Op("*", [@Number(n), @Op("**", [sym, @Number(n-1)])]);
						}
					} else if (fct(base) == "Op" || fct(base) == "Func") {
						assert(false, "Differentiation of exponents of operator or function bases are not implemented yet.");
					} else {
						return @Number(0);
					}
				}
			],
			[
				params |-> fct(params[1]) == "Op" && args(params[1])[1] == "*",
				procedure(params) {
					sym := params[2];
					opTerm := params[1];
					opArgs := args(opTerm)[2];
					inner := [ @Op("*", [@Func("diff", [opArgs[i], sym])] + [opArgs[j] : j in {1..#opArgs} | i != j]) : i in {1..#opArgs} ];
					return @Op("+", inner);
				}
			],
			[
				params |-> fct(params[1]) == "Op" && args(params[1])[1] == "/",
				procedure(params) {
					sym := params[2];
					opTerm := params[1];
					opArgs := args(opTerm)[2];
					inner := [ @Op("*", [@Func("diff", [opArgs[i], sym])] + [opArgs[j] : j in {1..#opArgs} | i != j]) : i in {1..#opArgs} ];
					dens := [ @Op("*", [x, x]) : x in opArgs[2..] ];
					return @Op("/", [@Op("-", inner)] + dens);
				}
			],
			chainRule("diff", diffFuncRules)
		]],
		["sin", [
			checkArityRule("sin", 1),
			[
				params |-> fct(params[1]) == "Number",
				params |-> sin(params[1][1])
			]
		]],
		["cos", [
			checkArityRule("cos", 1),
			[
				params |-> fct(params[1]) == "Number",
				params |-> cos(params[1][1])
			]
		]]
	]);
};



eval := procedure(expr, rules) {
	if (isString(expr)) {
		expr := parse(expr);
	}
	if (global.DEBUG) {
		print("Evaluating $expr$...");
	}
	match(expr) {
		case @Number(n):
			return expr;
		case @Name(s):
			return expr;
		case @Func(f, params):
			if (f in domain(rules)) {
				if (global.DEBUG) {
					print("func: $f$ - params: $params$");
				}
				params := [ eval(p, rules) : p in params ];
				for (r in rules[f]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						res := e(params);
						if (global.DEBUG) {
							print("Applied rule: $r$");
							print("Result: $res$");
						}
						return eval(res, rules);
					}
				}
				return @Func(f, params);
			} else {
				abort("Error at eval($expr$) - Function not found in rules.");
			}
		case @Op(op, params):
			if (op in domain(rules)) {
				if (global.DEBUG) {
					print("op: $op$ - params: $params$");
				}
				params := [ eval(p, rules) : p in params ];
				for (r in rules[op]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						res := e(params);
						if (global.DEBUG) {
							print("Applied rule: $r$");
							print("Result: $res$");
						}
						return eval(res, rules);
					}
				}
				return @Op(op, params);
			} else {
				abort("Error at eval($expr$) - Operation not found in rules.");
			}
		case @UnaryOp(op, param):
			if (op in domain(rules)) {
				if (global.DEBUG) {
					print("unaryOp: $op$ - param: $param$");
				}
				params := [eval(param, rules)];
				for (r in rules[op]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						res := e(params);
						if (global.DEBUG) {
							print("Applied rule: $r$");
							print("Result: $res$");
						}
						return eval(res, rules);
					}
				}
				return @UnaryOp(op, params);
			} else {
				abort("Error at eval($expr$) - Unary Operation not found in rules.");
			}
		default: abort("Error at eval($expr$) - Unknown Expression.");
	}
};

getMaxPrec := procedure() {
	return 3;
};

getOpPrec := procedure(op) {
	match(op) {
		case "**":
			return 3;
		case "*":
			return 2;
		case "/":
			return 2;
		case "+":
			return 1;
		case "-":
			return 1;
		default:
			abort("Error at getOpPrec($op$) - Unknown operator");
	}
};

isOpRightAssoc := procedure(op) {
	match(op) {
		case "**":
			return true;
		default:
			return false;
	}
};

idxOfClosedParan := procedure(tokens) {
	if (global.DEBUG) {
		print("Finding index of closed parantheses $tokens$...");
	}
	parans := 1;
	i := 1;
	while (parans != 0 && i <= #tokens) {
		match(tokens[i]) {
			case @TokParanOpen():
				parans += 1;
			case @TokParanClosed():
				parans -= 1;
		}
		i += 1;
	}

	if (parans == 0) {
		return i-1;
	} else {
		abort("Error at idxOfClosedParan($tokens$): Unmatched Parantheses.");
	}
};

parse := procedure(tokens) {
	if (isString(tokens)) {
		tokens := tokenize(tokens);
	}
	return parseExpr(tokens);
};

parseExprList := procedure(tokens) {
	if (global.DEBUG) {
		print("Parsing expression-list $tokens$...");
	}

	exprs := [];
	parans := 1;
	i := 1;
	while (parans != 0 && #tokens >= i) {
		match(tokens[i]) {
			case @TokParanOpen():
				parans += 1;
			case @TokParanClosed():
				parans -= 1;
			case @TokComma():
				if (parans == 1) {
					exprs += [tokens[..i-1]];
					tokens := tokens[i+1..];
					i := 0;
				}
		}
		i += 1;
	}

	if (parans == 0) {
		exprs += [tokens[..-2]];
		exprs := [ parseExpr(x) : x in exprs ];
		return exprs;
	} else {
		abort("Error at parseExprList($tokens$): Unmatched Parantheses.");
	}
};

parseExpr := procedure(tokens, last := om, lastPrec := om, paranLevel := 0) {
	if (global.DEBUG) {
		print("Parsing expression $tokens$ with last: $last$...");
	}
	if (tokens == []) {
		return last;
	}
	if (last == om && fct(tokens[1]) != "TokOp") {
		return parseTerm(tokens, true, paranLevel);
	}

	expr := om;
	token := tokens[1];
	tokens := tokens[2..];
	currPrec := om;
	match(token) {
		case @TokOp(op):
			next := parseTerm(tokens, false, paranLevel);
			currPrec := getOpPrec(op) + paranLevel * getMaxPrec();
			if (global.DEBUG) {
				print("next: $next$");
				print("currPrec: $currPrec$");
			}
			if (last == om) {
				expr := @UnaryOp(op, next);
			} else if (fct(last) == "Op") {
				[lastOp, params] := args(last);
				assert(#params >= 2, "There must be at least 2 parameters for a prefix operator. The operator $lastOp$ only received the parameters $params$");

				if (op == lastOp) {
					if (isOpRightAssoc(op)) {
						expr := @Op(op, [next] + params);
					} else {
						expr := @Op(op, params + [next]);
					}
				} else {
					if (currPrec > lastPrec) {
						expr := @Op(lastOp, params[..-2] + [@Op(op, [params[-1], next])]);
					} else {
						expr := @Op(op, [last, next]);
					}
				}
			} else {
				expr := @Op(op, [last, next]);
			}
		default:
			expr := parseTerm(tokens, false, paranLevel);
	}
	if (global.DEBUG) {
		print("Parsing done - Result: $expr$");
	}
	return parseExpr(tokens, expr, currPrec, paranLevel);
};

parseTerm := procedure(rw tokens, rec := false, paranLevel := 0) {
	assert(tokens != [], "parseTerm expects a non-empty list as input");
	if (global.DEBUG) {
		print("Parsing term $tokens$ with rec: $rec$...");
	}
	match(tokens[1]) {
		case @TokNum(num):
			tokens := tokens[2..];
			if (rec) {
				return parseExpr(tokens, @Number(num), om, paranLevel);
			} else {
				return @Number(num);
			}
		case @TokName(name):
			// Name + ParanOpen + ParanClosed are required for it to be a function-call
			if (#tokens > 3 && fct(tokens[2]) == "TokParanOpen") {
				tokens := tokens[3..];
				idx := idxOfClosedParan(tokens);
				assert(fct(tokens[idx]) == "TokParanClosed", "The index returned by idxOfClosedParan should point to a closing parantheses. Returned index is $idx$ and points at $tokens[idx]$");
				innerArgs := tokens[..idx];
				tokens := tokens[idx+2..];
				params := parseExprList(innerArgs);
				if (rec) {
					return parseExpr(tokens, @Func(name, params), om, paranLevel);
				} else {
					return @Func(name, params);
				}
			} else {
				tokens := tokens[2..];
				if (rec) {
					return parseExpr(tokens, @Name(name), om, paranLevel);
				} else {
					return @Name(name);
				}
			}
		case @TokParanOpen():
			tokens := tokens[2..];
			idx := idxOfClosedParan(tokens);
			expr := parseExpr(tokens[..idx-1], om, om, paranLevel + 1);
			lastPrec := om;
			if (fct(expr) == "Op") {
				lastPrec := getOpPrec(args(expr)[1]) + getMaxPrec() * (paranLevel + 1);
			}
			tokens := tokens[idx+1..];
			if (rec) {
				return parseExpr(tokens, expr, lastPrec, paranLevel);
			} else {
				return expr;
			}
		default: abort("Error at parseTerm($tokens$) - Unexpected token");
	}
};

tokenize := procedure(str) {
	if (global.DEBUG) {
		print("Tokenizing $str$...");
	}
	toks := [];
	scan(str) {
		regex '\s+': // Skip starting whitespace
		regex '[a-zA-Z][a-zA-Z_0-9]*' as [ name ]:
			toks += [ @TokName(name) ];
		regex '(0|[1-9][0-9]*).[0-9]+' as [ num, _ ]:
			toks += [ @TokNum(double(num)) ];
		regex '0|[1-9][0-9]*' as [ num ]:
			toks += [ @TokNum(int(num)) ];
		regex '\(':
			toks += [ @TokParanOpen() ];
		regex '\)':
			toks += [ @TokParanClosed() ];
		regex ',':
			toks += [ @TokComma() ];
		regex '\*\*|[+\-\*/]' as [ op ]:
			toks += [ @TokOp(op) ];
		default: abort("Error at tokenize($str$) - Can't tokenize $str$ properly");
	}
	return toks;
};

stringify := procedure(expr, outsidePrec := om) {
	if (global.DEBUG) {
		print("Stringifying $expr$ with outsideOp = $outsideOp$...");
	}
	match(expr) {
		case @Name(s):
			return s;
		case @Number(n):
			return "$n$";
		case @Func(f, params):
			params := [ stringify(p) : p in params ];
			params := join(params);
			return "$f$($params$)";
		case @Op(op, params):
			prec := getOpPrec(op);
			params := [ stringify(p, prec) : p in params ];
			res := join(params, " $op$ ");
			if (isInteger(outsidePrec) && outsidePrec > prec) {
				return "($res$)";
			} else {
				return res;
			}
		default: abort("Error at stringify($expr$, $outsideOp$) - Unexpected expression.");
	}
};

evalStr := procedure(strs, rules, includeBefore := true, toPrint := true) {
	pad := 0;
	if (isList(strs)) {
		lengths := [#s : s in strs];
		pad := max(lengths);
	} else {
		strs := [strs];
	}

	outStrs := [];
	for (s in strs) {
		// global.DEBUG := true;
		// global.DEBUG := false;
		tokens := tokenize(s);
		expr := parse(tokens);
		res := eval(expr, rules);
		outStr := stringify(res);

		if (includeBefore) {
			padding := '';
			if (pad > #s) {
				padding := ' ' * (pad - #s);
			}
			outStr := "$s$$padding$ -->  $outStr$";
		}
		if (toPrint) {
			print(outStr);
		}
		outStrs += [outStr];
	}
	return outStrs;
};



rules := makeDefaultRules();
evalStr([
	"x + 0",
	"x * 0",
	"x + 0 * b - 6 - 3",
	"(x + 7) * 34",
	// "diff(a, a)",
	// "diff(diff(x * x * y, x), y)",
	// "diff(f / g / h, f)",
	// "diff(x * x, x)",
	// "(x * (7 + 8 / x)) - diff(7 * x * x * x, x)",
	// "diff(diff(cos(sin(x)), x), x)",
	"-6 * (-3) * x",
	"diff((x ** 2) + sin(x), x)"
], rules);