class global() {
	static {
		DEBUG := false;
	}
}

reduceFromFirst := procedure(l, f) {
	assert(l != [], "reduceFromFirst expects a non-empty list as input");
	res := l[1];
	for (x in l[2..]) {
		res := f(res, x);
	}
	return res;
};

join := procedure(l, del := ", ") {
	match(l) {
		case []:    return "";
		case [x]:   return "$x$";
		case [x|r]: return "$x$$del$$join(r, del)$";
	}
};

// Returns true, if at least f(x) returns true for at least two elements in l
some := procedure(l, f) {
	foundOne := false;
	for (x in l) {
		if (f(x)) {
			if (!foundOne) {
				foundOne := true;
			} else {
				return true;
			}
		}
	}
	return false;
};

// Splits a list in two sublists.
// The first sublists contains all elements for which f(x) is true.
// The second sublist contains all other elements.
splitListInTwo := procedure(l, f) {
	a := [];
	b := [];
	for (x in l) {
		if (f(x)) {
			a += [x];
		} else {
			b += [x];
		}
	}
	return [a, b];
};

addOpRule := procedure(rw rules, op, test, eval) {
	if (op in domain(rules)) {
		rules[op] += [[test, eval]];
	} else {
		rules[op] := [[test, eval]];
	}
	return rules;
};

addOpRules := procedure(rw rules, op, newRules) {
	for (newRule in newRules) {
		assert(#newRule == 2, "An evalutation rule always has to consist of exactly two functions, a test and an eval function.");
		addOpRule(rules, op, newRule[1], newRule[2]);
	}
	return rules;
};

allNumRule := procedure(reduceOp) {
	return [
		params |-> forall (p in params | fct(p) == "Number"),
		[params, prec] |=> @Number(reduceFromFirst([ args(p)[1] : p in params ], reduceOp))
	];
};

someNumRule := procedure(op, reduceOp) {
	return [
		params |-> some(params, p |-> fct(p) == "Number"),
		closure(params, prec) {
			[ nums, others ] := splitListInTwo(params, p |-> fct(p) == "Number");
			n := reduceFromFirst([ args(n)[1] : n in nums ], reduceOp);
			return @Op(op, others + [@Number(n)], prec);
		}
	];
};

someNumAfterFirstRule := procedure(op, reduceOp) {
	return [
		params |-> some(params[2..], p |-> fct(p) == "Number"),
		closure(params, prec) {
			[ nums, others ] := splitListInTwo(params[2..], p |-> fct(p) == "Number");
			n := reduceFromFirst([ args(n)[1] : n in nums ], reduceOp);
			return @Op(op, [params[1]] + others + [@Number(n)], prec);
		}
	];
};

neutralElRule := procedure(op, e) {
	return [
		params |=> exists (p in params | fct(p) == "Number" && args(p)[1] == e),
		closure(params, prec) {
			params := [ p : p in params | fct(p) != "Number" || args(p)[1] != e ];
			if (#params == 1) {
				return params[1];
			} else {
				return @Op(op, params, prec);
			}
		}
	];
};

defaultRules := procedure() {
	rules := {};
	r := [
		["+", [
			allNumRule([a, b] |-> a + b),
			someNumRule("+", [a, b] |-> a + b),
			neutralElRule("+", 0)
		]],
		["*", [
			allNumRule([a, b] |-> a * b),
			someNumRule("*", [a, b] |-> a * b),
			[
				params |-> exists (p in params | fct(p) == "Number" && args(p)[1] == 0),
				[params, prec] |-> @Number(0)
			],
			neutralElRule("*", 1)
		]],
		["-", [
			allNumRule([a, b] |-> a - b),
			someNumAfterFirstRule("-", [a, b] |-> a + b),
			neutralElRule("-", 0)
		]],
		["/", [
			[
				params |-> exists (p in params[2..] | fct(p) == "Number" && args(p)[1] == 0),
				[params, prec] |-> abort("Division by 0,")
			],
			[
				params |-> fct(params[1]) == "Number" && args(params[1])[1] == 0,
				[params, prec] |-> @Number(0)
			],
			allNumRule([a, b] |-> a / b),
			someNumAfterFirstRule("/", [a, b] |-> a * b),
			[
				params |-> exists (p in params[2..] | fct(p) == "Number" && args(p)[1] == 1),
				procedure(params, prec) {
					den := [ p : p in params[2..] | fct(p) != "Number" || args(p)[1] != 1 ];
					if (den == []) {
						return params[1];
					} else {
						return @Op("/", [params[1]] + den, prec);
					}
				}
			]
		]]
	];
	for (rule in r) {
		addOpRules(rules, rule[1], rule[2]);
	}
	return rules;
};



eval := procedure(expr, rules) {
	if (isString(expr)) {
		expr := parse(expr);
	}
	if (global.DEBUG) {
		print("Evaluating $expr$...");
	}
	match(expr) {
		case @Number(n):
			return expr;
		case @Name(s):
			return expr;
		case @Func(f, params):
			// TODO use rules to determine evaluation
			assert(false, "evaluating functions is not yet implemented");
		case @Op(op, params, prec):
			if (op in domain(rules)) {
				params := [ eval(p, rules) : p in params ];
				if (global.DEBUG) {
					print("params: $params$");
				}
				for (r in rules[op]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						return e(params, prec);
					}
				}
				return @Op(op, params, prec);
			} else {
				abort("Error at eval($expr$) - Operation not found in rules.");
			}
		default: abort("Error at eval($expr$) - Unknown Expression.");
	}
};

getMaxPrec := procedure() {
	return 3;
};

getOpPrec := procedure(op) {
	match(op) {
		case "**":
			return 3;
		case "*":
			return 2;
		case "/":
			return 2;
		case "+":
			return 1;
		case "-":
			return 1;
		default:
			abort("Error at getOpPrec($op$) - Unknown operator");
	}
};

isOpRightAssoc := procedure(op) {
	match(op) {
		case "**":
			return true;
		default:
			return false;
	}
};

idxOfClosedParan := procedure(tokens) {
	parans := 1;
	i := 1;
	while (parans != 0 && #tokens >= i) {
		match(tokens[i]) {
			case @TokParanOpen():
				parans += 1;
			case @TokParanClosed():
				parans -= 1;
		}
		i += 1;
	}

	if (parans == 0) {
		return i;
	} else {
		abort("Error at idxOfClosedParan($tokens$): Unmatched Parantheses.");
	}
};

parse := procedure(tokens) {
	if (isString(tokens)) {
		tokens := tokenize(tokens);
	}
	return parseExpr(tokens);
};

parseExprList := procedure(tokens) {
	if (global.DEBUG) {
		print("Parsing expression-list $tokens$...");
	}
	assert(false, "parseExprList is not yet implemented");
	res := [];
	// while(test) {
	// 	body
	// }
	return res;
};

parseExpr := procedure(tokens, last := om, paranLevel := 0) {
	if (global.DEBUG) {
		print("Parsing expression $tokens$ with last: $last$...");
	}
	if (tokens == []) {
		return last;
	}
	if (last == om) {
		return parseTerm(tokens, true, paranLevel);
	}

	expr := om;
	token := tokens[1];
	tokens := tokens[2..];
	match(token) {
		case @TokOp(op):
			next := parseTerm(tokens, false, paranLevel);
			currPrec := getOpPrec(op) + paranLevel * getMaxPrec();
			if (global.DEBUG) {
				print("next: $next$");
				print("currPrec: $currPrec$");
			}
			if (fct(last) == "Op") {
				[lastOp, params, lastPrec] := args(last);
				assert(#params >= 2, "There must be at least 2 parameters for a prefix operator. The operator $lastOp$ only received the parameters $params$");

				if (op == lastOp) {
					if (isOpRightAssoc(op)) {
						expr := @Op(op, [next] + params, currPrec);
					} else {
						expr := @Op(op, params + [next], currPrec);
					}
				} else {
					if (currPrec > lastPrec) {
						expr := @Op(lastOp, params[..-2] + [@Op(op, [params[-1], next], lastPrec)], currPrec);
					} else {
						expr := @Op(op, [last, next], currPrec);
					}
				}
			} else {
				expr := @Op(op, [last, next], currPrec);
			}
		default:
			expr := parseTerm(tokens, false, paranLevel);
	}
	if (global.DEBUG) {
		print("Parsing done - Result: $expr$");
	}
	return parseExpr(tokens, expr);
};

parseTerm := procedure(rw tokens, rec := false, paranLevel := 0) {
	assert(tokens != [], "parseTerm expects a non-empty list as input");
	if (global.DEBUG) {
		print("Parsing term $tokens$ with rec: $rec$...");
	}
	match(tokens[1]) {
		case @TokNum(num):
			tokens := tokens[2..];
			if (rec) {
				return parseExpr(tokens, @Number(num), paranLevel);
			} else {
				return @Number(num);
			}
		case @TokName(name):
			// Name + ParanOpen + ParanClosed are required for it to be a function-call
			if (#tokens > 3 && fct(tokens[2]) == "TokParanOpen") {
				idx := idxOfClosedParan(tokens[3..]);
				params := parseExprList(tokens[3..idx], om, paranLevel);
				tokens := tokens[idx+2..];
				if (rec) {
					return parseExpr(tokens, @Func(name, params), paranLevel);
				} else {
					return @Func(name, params);
				}
			} else {
				tokens := tokens[2..];
				if (rec) {
					return parseExpr(tokens, @Name(name), paranLevel);
				} else {
					return @Name(name);
				}
			}
		case @TokParanOpen():
			idx := idxOfClosedParan(tokens[2..]);
			expr := parseExpr(tokens[2..idx-1], om, paranLevel + 1);
			tokens := tokens[idx+1..];
			if (rec) {
				return parseExpr(tokens, expr, paranLevel);
			} else {
				return expr;
			}
		default: abort("Error at parseTerm($tokens$) - Unexpected token");
	}
};

tokenize := procedure(str) {
	if (global.DEBUG) {
		print("Tokenizing $str$...");
	}
	toks := [];
	scan(str) {
		regex '\s+': // Skip starting whitespace
		regex '[a-zA-Z][a-zA-Z_0-9]*' as [ name ]:
			toks += [ @TokName(name) ];
		regex '(0|[1-9][0-9]*).(0|[1-9][0-9]*)' as [ a, b ]:
			toks += [ @TokNum(real("$a$.$b$")) ];
		regex '0|[1-9][0-9]*' as [ num ]:
			toks += [ @TokNum(int(num)) ];
		regex '\(':
			toks += [ @TokParanOpen() ];
		regex '\)':
			toks += [ @TokParanClosed() ];
		regex ',':
			toks += [ @TokComma() ];
		regex '\*\*|[+\-\*/]' as [ op ]:
			toks += [ @TokOp(op) ];
		default: abort("Error at tokenize($str$) - Can't tokenize $str$ properly");
	}
	return toks;
};

stringify := procedure(expr, outsidePrec := om) {
	if (global.DEBUG) {
		print("Stringifying $expr$ with outsideOp = $outsideOp$...");
	}
	match(expr) {
		case @Name(s):
			return s;
		case @Number(n):
			return "$n$";
		case @Func(f, params):
			params := [ stringify(p) : p in params ];
			params := join(params);
			return "$f$($params$)";
		case @Op(op, params, prec):
			params := [ stringify(p, prec) : p in params ];
			res := join(params, " $op$ ");
			if (outsidePrec != om && prec > outsidePrec) {
				return "($res$)";
			} else {
				return res;
			}
		default: abort("Error at stringify($expr$, $outsideOp$) - Unexpected expression.");
	}
};

evalStr := procedure(str, rules, includeBefore := true) {
	tokens := tokenize(str);
	expr := parse(tokens);
	res := eval(expr, rules);
	outStr := stringify(res);
	if (includeBefore) {
		return "$str$ -> $outStr$";
	} else {
		return outStr;
	}
};



rules := defaultRules();
print(evalStr("a + 0", rules));
print(evalStr("a * 0", rules));
print(evalStr("a + 0 * b - 6 - 3", rules));
print(evalStr("(a + 7) * 34", rules));
// print(evalStr("diff(diff(x * x * y, x), y)", rules));
// print(evalStr("diff(sin(cos(x)), x)", rules));
// print(defaultRules());