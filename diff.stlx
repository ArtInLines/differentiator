load("util.stlx");
load("rules.stlx");


class global() {
	static {
		rules := makeDefaultRules();
		DEBUG := false;
	}
}


eval := procedure(expr, rules := global.rules) {
	if (isString(expr)) {
		expr := parse(expr);
	}
	if (global.DEBUG) {
		print("Evaluating $expr$...");
	}
	match(expr) {
		case @Number(n):
			return expr;
		case @Name(s):
			return expr;
		case @Func(f, params):
			if (f in domain(rules)) {
				if (global.DEBUG) {
					print("func: $f$ - params: $params$");
				}
				params := [ eval(p, rules) : p in params ];
				for (r in rules[f]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						res := e(params);
						if (global.DEBUG) {
							print("Applied rule: $r$");
							print("Result: $res$");
						}
						return eval(res, rules);
					}
				}
				return @Func(f, params);
			} else {
				abort("Error at eval($expr$) - Function not found in rules.");
			}
		case @Op(op, params):
			if (op in domain(rules)) {
				if (global.DEBUG) {
					print("op: $op$ - params: $params$");
				}
				params := [ eval(p, rules) : p in params ];
				for (r in rules[op]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						res := e(params);
						if (global.DEBUG) {
							print("Applied rule: $r$");
							print("Result: $res$");
						}
						return eval(res, rules);
					}
				}

				if (global.DEBUG) {
					print("No applicable rule - returning $@Op(op, params)$");
				}
				return @Op(op, params);
			} else {
				abort("Error at eval($expr$) - Operation not found in rules.");
			}
		case @UnaryOp(op, param):
			if (op in domain(rules)) {
				if (global.DEBUG) {
					print("unaryOp: $op$ - param: $param$");
				}
				params := [eval(param, rules)];
				for (r in rules[op]) {
					assert(#r == 2, "Each rule is expected to have exactly 2 elements");
					t := r[1];
					e := r[2];
					if (t(params)) {
						res := e(params);
						if (global.DEBUG) {
							print("Applied rule: $r$");
							print("Result: $res$");
						}
						return eval(res, rules);
					}
				}
				return @UnaryOp(op, params);
			} else {
				abort("Error at eval($expr$) - Unary Operation not found in rules.");
			}
		default: abort("Error at eval($expr$) - Unknown Expression.");
	}
};

getMaxPrec := procedure() {
	return 3;
};

getOpPrec := procedure(op) {
	match(op) {
		case "^":
			return 3;
		case "*":
			return 2;
		case "/":
			return 2;
		case "+":
			return 1;
		case "-":
			return 1;
		default:
			abort("Error at getOpPrec($op$) - Unknown operator");
	}
};

isOpRightAssoc := procedure(op) {
	match(op) {
		case "^":
			return true;
		default:
			return false;
	}
};

idxOfClosedParan := procedure(tokens) {
	if (global.DEBUG) {
		print("Finding index of closed parantheses $tokens$...");
	}
	parans := 1;
	i := 1;
	while (parans != 0 && i <= #tokens) {
		match(tokens[i]) {
			case @TokParanOpen():
				parans += 1;
			case @TokParanClosed():
				parans -= 1;
		}
		i += 1;
	}

	if (parans == 0) {
		return i-1;
	} else {
		abort("Error at idxOfClosedParan($tokens$): Unmatched Parantheses.");
	}
};

parse := procedure(tokens) {
	if (isString(tokens)) {
		tokens := tokenize(tokens);
	}
	return parseExpr(tokens);
};

parseExprList := procedure(tokens) {
	if (global.DEBUG) {
		print("Parsing expression-list $tokens$...");
	}

	exprs := [];
	parans := 1;
	i := 1;
	while (parans != 0 && #tokens >= i) {
		match(tokens[i]) {
			case @TokParanOpen():
				parans += 1;
			case @TokParanClosed():
				parans -= 1;
			case @TokComma():
				if (parans == 1) {
					exprs += [tokens[..i-1]];
					tokens := tokens[i+1..];
					i := 0;
				}
		}
		i += 1;
	}

	if (parans == 0) {
		exprs += [tokens[..-2]];
		exprs := [ parseExpr(x) : x in exprs ];
		return exprs;
	} else {
		abort("Error at parseExprList($tokens$): Unmatched Parantheses.");
	}
};

parseExpr := procedure(tokens, last := om, lastPrec := om, paranLevel := 0) {
	if (global.DEBUG) {
		print("Parsing expression $tokens$ with last: $last$...");
	}
	if (tokens == []) {
		return last;
	}
	if (last == om && fct(tokens[1]) != "TokOp") {
		if (global.DEBUG) {
			print("last is om && first token is not op: $tokens[1]$");
		}
		return parseTerm(tokens, true, paranLevel);
	}

	expr := om;
	token := tokens[1];
	tokens := tokens[2..];
	currPrec := om;
	match(token) {
		case @TokOp(op):
			next := parseTerm(tokens, false, paranLevel);
			currPrec := getOpPrec(op) + paranLevel * getMaxPrec();
			if (global.DEBUG) {
				print("next: $next$");
				print("lastPrec: $lastPrec$");
				print("currPrec: $currPrec$");
				print("last: $last$");
			}
			if (last == om) {
				expr := @UnaryOp(op, next);
			} else if (fct(last) == "Op") {
				[lastOp, params] := args(last);
				assert(#params >= 2, "There must be at least 2 parameters for a prefix operator. The operator $lastOp$ only received the parameters $params$");

				if (op == lastOp) {
					expr := @Op(op, params + [next]);
				} else if (lastPrec < currPrec) {
					expr := @Op(lastOp, params[..-2] + [@Op(op, [params[-1], next])]);
					currPrec := lastPrec;
				} else {
					expr := @Op(op, [last, next]);
				}
			} else {
				expr := @Op(op, [last, next]);
			}
		default:
			expr := parseTerm(tokens, false, paranLevel);
	}
	if (global.DEBUG) {
		print("Parsing done - Result: $expr$");
	}
	return parseExpr(tokens, expr, currPrec, paranLevel);
};

parseTerm := procedure(rw tokens, rec := false, paranLevel := 0) {
	assert(tokens != [], "parseTerm expects a non-empty list as input");
	if (global.DEBUG) {
		print("Parsing term $tokens$ with rec: $rec$...");
	}
	match(tokens[1]) {
		case @TokNum(num):
			tokens := tokens[2..];
			if (rec) {
				return parseExpr(tokens, @Number(num), om, paranLevel);
			} else {
				return @Number(num);
			}
		case @TokName(name):
			// Name + ParanOpen + ParanClosed are required for it to be a function-call
			if (#tokens > 3 && fct(tokens[2]) == "TokParanOpen") {
				tokens := tokens[3..];
				idx := idxOfClosedParan(tokens);
				assert(fct(tokens[idx]) == "TokParanClosed", "The index returned by idxOfClosedParan should point to a closing parantheses. Returned index is $idx$ and points at $tokens[idx]$");
				innerArgs := tokens[..idx];
				tokens := tokens[idx+1..];
				params := parseExprList(innerArgs);
				if (rec) {
					return parseExpr(tokens, @Func(name, params), om, paranLevel);
				} else {
					return @Func(name, params);
				}
			} else {
				tokens := tokens[2..];
				if (rec) {
					return parseExpr(tokens, @Name(name), om, paranLevel);
				} else {
					return @Name(name);
				}
			}
		case @TokParanOpen():
			tokens := tokens[2..];
			idx := idxOfClosedParan(tokens);
			expr := parseExpr(tokens[..idx-1], om, om, paranLevel + 1);
			lastPrec := om;
			if (fct(expr) == "Op") {
				lastPrec := getOpPrec(args(expr)[1]) + getMaxPrec() * (paranLevel + 1);
			}
			tokens := tokens[idx+1..];
			if (rec) {
				return parseExpr(tokens, expr, lastPrec, paranLevel);
			} else {
				return expr;
			}
		default: abort("Error at parseTerm($tokens$) - Unexpected token");
	}
};

tokenize := procedure(str) {
	if (global.DEBUG) {
		print("Tokenizing $str$...");
	}
	toks := [];
	scan(str) {
		regex '\s+': // Skip starting whitespace
		regex '[a-zA-Z][a-zA-Z_0-9]*' as [ name ]:
			toks += [ @TokName(name) ];
		regex '(0|[1-9][0-9]*).[0-9]+' as [ num, _ ]:
			toks += [ @TokNum(double(num)) ];
		regex '0|[1-9][0-9]*' as [ num ]:
			toks += [ @TokNum(int(num)) ];
		regex '\(':
			toks += [ @TokParanOpen() ];
		regex '\)':
			toks += [ @TokParanClosed() ];
		regex ',':
			toks += [ @TokComma() ];
		regex '[\^+\-\*/]' as [ op ]:
			toks += [ @TokOp(op) ];
		default: abort("Error at tokenize($str$) - Can't tokenize $str$ properly");
	}
	return toks;
};

stringify := procedure(expr, pretty := true, outsidePrec := om) {
	if (global.DEBUG) {
		print("Stringifying $expr$ with outsideOp = $outsideOp$...");
	}
	match(expr) {
		case @Name(s):
			return s;
		case @Number(n):
			return "$n$";
		case @Func(f, params):
			params := [ stringify(p, pretty) : p in params ];
			params := join(params);
			return "$f$($params$)";
		case @Op(op, params):
			prec := getOpPrec(op);
			res := om;
			opStr := " $op$ ";
			if (op == "^") {
				opStr := "^";
			}

			if (pretty && op == "*" && exists (p in params | fct(p) == "Name")) {
				names := [ stringify(p, pretty) : p in params | fct(p) == "Name" ];
				nums := [ stringify(p, pretty) : p in params | fct(p) == "Number" ];
				others := [ stringify(p, pretty) : p in params | fct(p) notin { "Name", "Number" }];
				assert(#nums <= 1, "A product shouldn't have more than 1 number after being evaluated");
				res := join(nums + names, "");
				res := join([res] + others, opStr);
			} else {
				params := [ stringify(p, pretty, prec) : p in params ];
				res := join(params, opStr);
			}

			if (isInteger(outsidePrec) && outsidePrec > prec) {
				return "($res$)";
			} else {
				return res;
			}
		default: abort("Error at stringify($expr$, $outsideOp$) - Unexpected expression.");
	}
};

evalStr := procedure(strs, rules := global.rules, pretty := true, includeBefore := true, toPrint := true) {
	pad := 0;
	if (isList(strs)) {
		lengths := [#s : s in strs];
		pad := max(lengths);
	} else {
		strs := [strs];
	}

	outStrs := [];
	for (s in strs) {
		// global.DEBUG := true;
		// global.DEBUG := false;
		tokens := tokenize(s);
		expr := parse(tokens);
		res := eval(expr, rules);
		outStr := stringify(res, pretty);

		if (includeBefore) {
			padding := '';
			if (pad > #s) {
				padding := ' ' * (pad - #s);
			}
			outStr := "$s$$padding$ -->  $outStr$";
		}
		if (toPrint) {
			print(outStr);
		}
		outStrs += [outStr];
	}
	return outStrs;
};
